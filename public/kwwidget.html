<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>카카오 → 노션 위젯 (통합)</title>

  <style>
:root{
  --r: 16px;
  --line:#e6e8ee;
  --text:#111827;
  --muted:#6b7280;

  --kp:#ffe500; /* kakao page */
  --kw:#facc15; /* kakao webtoon */
  --bg: transparent;
  --shadow: 0 10px 30px rgba(17,24,39,.08);

  --ok:#10b981;
  --bad:#ef4444;
}

*{box-sizing:border-box}
body{
  margin:0;
  padding:16px;
  background: var(--bg);
  color: var(--text);
  font-family: system-ui, -apple-system, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
}

.wrap{
  width: 100%;
  display:flex;
  justify-content:center;
}

.outer{
  width: min(1100px, 100%);
  border-radius: calc(var(--r) + 8px);
  padding: 8px;
  background: transparent;
  border: 2px solid var(--kp);
}

.grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.panel{
  background: rgba(255,255,255,.86);
  border: 1px solid var(--line);
  border-radius: var(--r);
  overflow:hidden;
  box-shadow: var(--shadow);
  min-height: 420px;
  position: relative;
  display:flex;
  flex-direction:column;
}

.head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 12px;
  padding: 14px 14px 10px 14px;
  border-bottom: 1px solid var(--line);
  background: rgba(255,255,255,.9);
}

.brand{
  display:flex;
  align-items:center;
  gap: 12px;
  min-width: 240px;
}

.logo{
  width: 44px;
  height: 44px;
  border-radius: 14px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight: 900;
  letter-spacing: -0.03em;
  border: 1px solid rgba(0,0,0,.08);
}

.logo.kp{ background: var(--kp); }
.logo.kw{ background: var(--kw); }

.title .name{
  font-size: 15px;
  font-weight: 900;
  letter-spacing: -0.02em;
}
.title .sub{
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
}

.actions{
  display:flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content:flex-end;
}

.btn{
  appearance:none;
  border: 1px solid var(--line);
  background: white;
  color: var(--text);
  padding: 8px 10px;
  font-size: 12px;
  border-radius: 999px;
  cursor:pointer;
  line-height: 1;
}

.btn:hover{ filter: brightness(.98); }
.btn:active{ transform: translateY(1px); }
.btn:disabled{ opacity:.6; cursor:not-allowed; }

.btn.ghost{ background: rgba(255,255,255,.7); }

.body{
  padding: 12px 14px 14px 14px;
  display:flex;
  flex-direction:column;
  gap: 12px;
  flex:1;
  min-height: 0;
}

.ta{
  width: 100%;
  height: 90px;
  resize: vertical;
  border-radius: 12px;
  border: 1px solid var(--line);
  padding: 12px;
  outline:none;
  font-size: 13px;
  line-height: 1.4;
  background: white;
}

.panel[data-platform="kakaopage"] .ta:focus{
  box-shadow: 0 0 0 3px rgba(255,229,0,.25);
}
.panel[data-platform="kakaowebtoon"] .ta:focus{
  box-shadow: 0 0 0 3px rgba(250,204,21,.25);
}

.preview{
  border: 1px solid var(--line);
  border-radius: 14px;
  background: rgba(255,255,255,.92);
  overflow:hidden;
  display:flex;
  flex-direction:column;
  min-height: 0;
  flex:1;
}

.preview-head{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding: 10px 12px;
  border-bottom: 1px solid var(--line);
  background: rgba(17,24,39,.02);
}

.preview-title{
  font-size: 13px;
  font-weight: 900;
  letter-spacing: -0.02em;
}

.preview-right{
  display:flex;
  align-items:center;
  gap: 8px;
}

.preview-meta{
  font-size: 12px;
  color: var(--muted);
}

.btn.batch{
  padding: 8px 10px;
  font-weight: 900;
}

.cards{
  padding: 10px 10px 12px 10px;
  display:flex;
  flex-direction:column;
  gap: 10px;
  overflow:auto;
}

.card{
  display:flex;
  gap: 10px;
  padding: 10px;
  border-radius: 14px;
  border: 1px solid var(--line);
  background: white;
  box-shadow: 0 6px 18px rgba(17,24,39,.06);
}

.cover{
  width: 64px;
  height: 86px;
  border-radius: 10px;
  background: rgba(17,24,39,.05);
  border: 1px solid rgba(0,0,0,.06);
  overflow:hidden;
  flex: 0 0 auto;
  display:flex;
  align-items:center;
  justify-content:center;
}

.cover img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

.cover .ph{
  font-size: 11px;
  color: var(--muted);
  text-align:center;
  padding: 8px;
}

.card-main{
  flex:1;
  min-width: 0;
  display:flex;
  flex-direction:column;
  gap: 6px;
}

.card-title{
  font-size: 13px;
  font-weight: 900;
  letter-spacing: -0.02em;
  overflow:hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.card-author{
  font-size: 12px;
  color: var(--muted);
  overflow:hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.card-actions{
  display:flex;
  gap: 8px;
  align-items:center;
  justify-content:flex-end;
  margin-top: auto;
}

.card-actions .mini{
  border-radius: 12px;
  padding: 8px 10px;
  font-weight: 900;
  border: 0;
}

.panel[data-platform="kakaopage"] .card-actions .mini{ background: var(--kp); }
.panel[data-platform="kakaowebtoon"] .card-actions .mini{ background: var(--kw); }

.pill{
  font-size: 11px;
  padding: 5px 8px;
  border-radius: 999px;
  border: 1px solid var(--line);
  color: var(--muted);
  background: rgba(17,24,39,.02);
}

.pill.ok{ color: var(--ok); border-color: rgba(16,185,129,.35); background: rgba(16,185,129,.08); }
.pill.bad{ color: var(--bad); border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.08); }

.skeleton{
  position: relative;
  overflow:hidden;
}
.skeleton::after{
  content:"";
  position:absolute; inset:0;
  transform: translateX(-100%);
  background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(17,24,39,.06) 50%, rgba(255,255,255,0) 100%);
  animation: shimmer 1.1s infinite;
}
@keyframes shimmer{
  100% { transform: translateX(100%); }
}

.toast{
  position:absolute;
  left: 14px;
  right: 14px;
  bottom: 14px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,.95);
  font-size: 12px;
  color: var(--text);
  display:none;
}
.toast.show{ display:block; }

.log{
  margin: 0;
  padding: 12px 14px 14px 14px;
  border-top: 1px dashed var(--line);
  background: rgba(17,24,39,.02);
  font-size: 12px;
  color: #111827;
  white-space: pre-wrap;
}

@media (max-width: 820px){
  .grid{ grid-template-columns: 1fr; }
  .outer{ border-color: var(--line); }
}
  </style>
</head>
<body>

<div class="wrap">
  <div class="outer">
    <div class="grid">

      <!-- LEFT: KakaoPage -->
      <section class="panel" data-platform="kakaopage">
        <header class="head">
          <div class="brand">
            <div class="logo kp">K</div>
            <div class="title">
              <div class="name">카카오페이지 URL</div>
              <div class="sub">한 줄에 URL 1개 → 아래 카드 미리보기 자동 생성</div>
            </div>
          </div>

          <div class="actions">
            <button class="btn ghost" data-action="log">로그 보기</button>
            <button class="btn ghost" data-action="first">첫 URL 열기</button>
            <button class="btn ghost" data-action="clear">입력 지우기</button>
          </div>
        </header>

        <div class="body">
          <textarea class="ta" placeholder="https://page.kakao.com/content/64257452 또는 작품 링크를 한 줄씩"></textarea>

          <div class="preview">
            <div class="preview-head">
              <div class="preview-title">미리보기</div>
              <div class="preview-right">
                <div class="preview-meta"><span class="count">0</span>개</div>
                <button class="btn ghost batch" data-action="save-all">전체 저장</button>
              </div>
            </div>
            <div class="cards"></div>
          </div>
        </div>

        <div class="toast" aria-live="polite"></div>
        <pre class="log" hidden></pre>
      </section>

      <!-- RIGHT: KakaoWebtoon -->
      <section class="panel" data-platform="kakaowebtoon">
        <header class="head">
          <div class="brand">
            <div class="logo kw">W</div>
            <div class="title">
              <div class="name">카카오웹툰 URL</div>
              <div class="sub">한 줄에 URL 1개 → 아래 카드 미리보기 자동 생성</div>
            </div>
          </div>

          <div class="actions">
            <button class="btn ghost" data-action="log">로그 보기</button>
            <button class="btn ghost" data-action="first">첫 URL 열기</button>
            <button class="btn ghost" data-action="clear">입력 지우기</button>
          </div>
        </header>

        <div class="body">
          <textarea class="ta" placeholder="https://webtoon.kakao.com/content/작품명/2873 처럼 한 줄씩"></textarea>

          <div class="preview">
            <div class="preview-head">
              <div class="preview-title">미리보기</div>
              <div class="preview-right">
                <div class="preview-meta"><span class="count">0</span>개</div>
                <button class="btn ghost batch" data-action="save-all">전체 저장</button>
              </div>
            </div>
            <div class="cards"></div>
          </div>
        </div>

        <div class="toast" aria-live="polite"></div>
        <pre class="log" hidden></pre>
      </section>

    </div>
  </div>
</div>

<script>
/**
 * ✅ 이 위젯은 "통째로 복붙" 전용 버전
 * - 카드 미리보기 자동 생성
 * - 카드별 저장 + "전체 저장"
 * - 출판사명은 표시하지 않음(요청사항)
 * - 19세 제목 표기는 서버(addToNotion)에서 "뒤에 1번만" 정리됨
 * - 제작진(원작/각색/그림)은 서버(getKakaoDetail)에서 authorName에 합쳐서 내려옴
 * - 장르의 '를' 같은 찌꺼기는 프론트/서버 양쪽에서 필터
 */
const BASE_URL = "https://notion-widget-server1.vercel.app";
const API_PARSE = "/api/parseKakao";
const API_ADD   = "/api/addToNotion";

const DEBOUNCE_MS = 450;
const CONCURRENCY = 3;

function fullUrl(path){
  if (!BASE_URL) return path;
  return BASE_URL.replace(/\/$/, "") + path;
}

function parseLines(text){
  return text.split("\n").map(s => s.trim()).filter(Boolean);
}

function isValidUrl(u){
  try { new URL(u); return true; } catch { return false; }
}

function platformFilter(platform, url){
  if (platform === "kakaopage") return url.includes("page.kakao.com");
  if (platform === "kakaowebtoon") return url.includes("webtoon.kakao.com");
  return true;
}

function showToast(panel, msg){
  const toast = panel.querySelector(".toast");
  toast.textContent = msg;
  toast.classList.add("show");
  clearTimeout(panel._toastTimer);
  panel._toastTimer = setTimeout(() => toast.classList.remove("show"), 2000);
}

// 로그는 에러만
function appendLog(panel, msg){
  const pre = panel.querySelector(".log");
  pre.hidden = false;
  pre.textContent = (pre.textContent ? pre.textContent + "\n" : "") + msg;
}

function setCount(panel, n){
  panel.querySelector(".count").textContent = String(n);
}

function cleanGenreArr(arr){
  const bad = new Set(["를", "을", "이", "가", "은", "는", "의", "에", "에서", "와", "과"]);
  return (arr || [])
    .map(x => String(x || "").trim())
    .filter(Boolean)
    .filter(x => !bad.has(x));
}

// ----------------- 캐시 + 동시성 제한 -----------------
const parsedCache = new Map();
const inflightCache = new Map();

function createLimiter(max){
  let active = 0;
  const queue = [];
  const runNext = () => {
    if (active >= max) return;
    const job = queue.shift();
    if (!job) return;
    active++;
    job().finally(() => { active--; runNext(); });
  };
  return function limit(fn){
    return new Promise((resolve, reject) => {
      queue.push(() => fn().then(resolve, reject));
      runNext();
    });
  };
}
const limit = createLimiter(CONCURRENCY);

// ----------------- API -----------------
async function fetchParse(url){
  if (parsedCache.has(url)) return parsedCache.get(url);
  if (inflightCache.has(url)) return inflightCache.get(url);

  const p = limit(async () => {
    const res = await fetch(fullUrl(`${API_PARSE}?url=${encodeURIComponent(url)}`), {
      method: "GET",
      headers: { "Accept": "application/json" }
    });
    const data = await res.json().catch(() => null);
    if (!res.ok || !data) throw new Error((data && data.error) || "파싱 실패");
    if (!data.ok) throw new Error(data.error || "파싱 실패");

    // 표시용 1차 정리
    if (Array.isArray(data.genre)) data.genre = cleanGenreArr(data.genre);

    parsedCache.set(url, data);
    return data;
  }).finally(() => inflightCache.delete(url));

  inflightCache.set(url, p);
  return p;
}

async function addToNotion(items){
  const res = await fetch(fullUrl(API_ADD), {
    method: "POST",
    headers: { "Content-Type": "application/json", "Accept": "application/json" },
    body: JSON.stringify({ items })
  });
  const data = await res.json().catch(() => null);
  if (!res.ok || !data) throw new Error((data && data.error) || "노션 저장 실패");
  if (data.ok === false) throw new Error(data.error || "노션 저장 실패");
  return data;
}

// ----------------- UI 카드 -----------------
function el(tag, cls){
  const e = document.createElement(tag);
  if (cls) e.className = cls;
  return e;
}

function createCard(panel, url){
  const card = el("div", "card");
  card.dataset.url = url;

  const cover = el("div", "cover skeleton");
  const ph = el("div", "ph");
  ph.textContent = "표지 불러오는 중…";
  cover.appendChild(ph);

  const main = el("div", "card-main");

  const title = el("div", "card-title skeleton");
  title.textContent = "제목 불러오는 중…";

  const meta = el("div", "card-author skeleton");
  meta.textContent = "작가 불러오는 중…";

  const actions = el("div", "card-actions");
  const pill = el("div", "pill");
  pill.textContent = "파싱 중…";

  const saveBtn = el("button", "btn mini");
  saveBtn.type = "button";
  saveBtn.textContent = "노션 저장";
  saveBtn.disabled = true;

  actions.appendChild(pill);
  actions.appendChild(saveBtn);

  main.appendChild(title);
  main.appendChild(meta);
  main.appendChild(actions);

  card.appendChild(cover);
  card.appendChild(main);

  saveBtn.addEventListener("click", async () => {
    const parsed = card._parsed;
    if (!parsed) return;
    await saveItems(panel, [card], [parsed]);
  });

  return card;
}

function setCardState(card, { status, msg }){
  const pill = card.querySelector(".pill");
  pill.classList.remove("ok", "bad");

  if (status === "ready") {
    pill.textContent = "준비 완료";
    pill.classList.add("ok");
  } else if (status === "saving") {
    pill.textContent = "저장 중…";
  } else if (status === "saved") {
    pill.textContent = "저장 완료";
    pill.classList.add("ok");
    card.dataset.saved = "1";
  } else if (status === "fail") {
    pill.textContent = msg || "실패";
    pill.classList.add("bad");
  }
}

function setCardSuccess(card, parsed){
  card._parsed = parsed;

  const titleText = parsed.title || "(제목 없음)";
  const authorText = (parsed.authorName || parsed.author || "").toString().trim();

  // cover
  const cover = card.querySelector(".cover");
  cover.classList.remove("skeleton");
  cover.innerHTML = "";

  const coverUrl = parsed.coverUrl || "";
  if (coverUrl){
    const img = document.createElement("img");
    img.src = coverUrl;
    img.alt = titleText;
    img.loading = "lazy";
    img.onerror = () => {
      cover.innerHTML = "";
      const ph = el("div", "ph");
      ph.textContent = "표지 로드 실패";
      cover.appendChild(ph);
    };
    cover.appendChild(img);
  } else {
    const ph = el("div", "ph");
    ph.textContent = "표지 없음";
    cover.appendChild(ph);
  }

  const title = card.querySelector(".card-title");
  title.classList.remove("skeleton");
  title.textContent = titleText;

  const meta = card.querySelector(".card-author");
  meta.classList.remove("skeleton");
  meta.textContent = authorText ? `작가: ${authorText}` : "작가: (없음)";

  const saveBtn = card.querySelector(".btn.mini");
  saveBtn.disabled = false;

  setCardState(card, { status: "ready" });
}

function setCardError(card, message){
  const cover = card.querySelector(".cover");
  cover.classList.remove("skeleton");
  cover.innerHTML = "";
  const ph = el("div", "ph");
  ph.textContent = "실패";
  cover.appendChild(ph);

  const title = card.querySelector(".card-title");
  title.classList.remove("skeleton");
  title.textContent = "파싱 실패";

  const meta = card.querySelector(".card-author");
  meta.classList.remove("skeleton");
  meta.textContent = message || "오류가 발생했어요.";

  const saveBtn = card.querySelector(".btn.mini");
  saveBtn.disabled = true;

  setCardState(card, { status: "fail", msg: "실패" });
}

// 공통 저장(단일/일괄)
async function saveItems(panel, cards, items){
  const pairs = cards
    .map((c, i) => ({ card: c, item: items[i] }))
    .filter(x => x.item && x.card && x.card.dataset.saved !== "1");

  if (!pairs.length) {
    showToast(panel, "저장할 카드가 없어요.");
    return;
  }

  for (const { card } of pairs) {
    const btn = card.querySelector(".btn.mini");
    btn.disabled = true;
    setCardState(card, { status: "saving" });
  }

  try{
    const payload = pairs.map(x => x.item);
    const result = await addToNotion(payload);

    const results = Array.isArray(result?.results) ? result.results : null;

    if (results) {
      for (let i = 0; i < pairs.length; i++) {
        const r = results[i];
        const card = pairs[i].card;
        const btn = card.querySelector(".btn.mini");

        if (r && r.ok) {
          setCardState(card, { status: "saved" });
        } else {
          setCardState(card, { status: "fail", msg: "저장 실패" });
          appendLog(panel, `✗ 저장 실패: ${pairs[i].item?.title || "(제목 없음)"}\n  ${(r && r.error) || "Unknown"}`);
        }
        btn.disabled = false;
      }
    } else {
      for (const { card } of pairs) {
        setCardState(card, { status: "saved" });
        card.querySelector(".btn.mini").disabled = false;
      }
    }

    showToast(panel, `${pairs.length}개 저장 완료!`);
  } catch(err){
    for (const { card } of pairs) {
      const btn = card.querySelector(".btn.mini");
      setCardState(card, { status: "fail", msg: "저장 실패" });
      btn.disabled = false;
    }
    appendLog(panel, `✗ 저장 오류: ${err.message}`);
    showToast(panel, err.message || "노션 저장 실패");
  }
}

function debounce(fn, ms){
  let t = null;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
}

document.querySelectorAll(".panel").forEach(panel => {
  const platform = panel.dataset.platform;
  const ta = panel.querySelector(".ta");
  const cardsWrap = panel.querySelector(".cards");

  let renderToken = 0;

  function clearCards(){
    cardsWrap.innerHTML = "";
    setCount(panel, 0);
  }

  function getFilteredUrls(){
    const urls = parseLines(ta.value)
      .filter(isValidUrl)
      .filter(u => platformFilter(platform, u));
    return Array.from(new Set(urls));
  }

  async function renderPreviews(){
    const token = ++renderToken;
    const urls = getFilteredUrls();
    setCount(panel, urls.length);

    if (!urls.length){
      clearCards();
      return;
    }

    const existing = new Map([...cardsWrap.querySelectorAll(".card")].map(c => [c.dataset.url, c]));
    const frag = document.createDocumentFragment();

    for (const url of urls){
      let card = existing.get(url);
      if (!card) card = createCard(panel, url);
      frag.appendChild(card);
    }
    cardsWrap.innerHTML = "";
    cardsWrap.appendChild(frag);

    for (const url of urls){
      if (token !== renderToken) return;

      const card = cardsWrap.querySelector(`.card[data-url="${CSS.escape(url)}"]`);
      if (!card) continue;
      if (card._parsed) continue;

      try{
        const parsed = await fetchParse(url);
        if (token !== renderToken) return;
        setCardSuccess(card, parsed);
      } catch(err){
        if (token !== renderToken) return;
        setCardError(card, err.message || "파싱 실패");
        appendLog(panel, `✗ 파싱 오류: ${url}\n  ${err.message}`);
      }
    }
  }

  ta.addEventListener("input", debounce(renderPreviews, DEBOUNCE_MS));

  panel.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-action]");
    if (!btn) return;

    const action = btn.dataset.action;

    if (action === "clear"){
      ta.value = "";
      clearCards();
      showToast(panel, "입력을 지웠어요.");
      return;
    }

    if (action === "first"){
      const urls = getFilteredUrls();
      if (!urls.length) return showToast(panel, "열 URL이 없어요.");
      window.open(urls[0], "_blank", "noopener,noreferrer");
      return;
    }

    if (action === "log"){
      const pre = panel.querySelector(".log");
      pre.hidden = !pre.hidden;
      showToast(panel, pre.hidden ? "로그를 숨겼어요." : "로그를 열었어요.");
      return;
    }

    if (action === "save-all"){
      const cards = [...panel.querySelectorAll(".card")];
      const ready = cards
        .filter(c => c._parsed)
        .filter(c => c.dataset.saved !== "1");

      if (!ready.length){
        showToast(panel, "저장할 카드가 없어요.");
        return;
      }

      btn.disabled = true;
      const old = btn.textContent;
      btn.textContent = "전체 저장 중…";

      try{
        const items = ready.map(c => c._parsed);
        await saveItems(panel, ready, items);
      } finally{
        btn.disabled = false;
        btn.textContent = old;
      }
    }
  });

  clearCards();
});
</script>

</body>
</html>
